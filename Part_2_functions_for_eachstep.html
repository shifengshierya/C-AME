<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>came.Part_2_functions_for_eachstep API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>came.Part_2_functions_for_eachstep</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python"># -*- coding: UTF-8 -*-
import numpy as np
import xlwt
import math
import pandas as pd
from pygam import LinearGAM
import os
from tqdm import tqdm
from pyproj import Transformer
from pyproj import CRS
from sklearn.cluster import MeanShift
from itertools import cycle
import matplotlib.pyplot as plt
from mpl_toolkits.basemap import Basemap
import pandas as pd
from sklearn.ensemble import RandomForestRegressor
from sklearn.neighbors import KNeighborsRegressor
import numpy as np
import matplotlib.pyplot as plt
from sklearn.metrics import mean_squared_error, r2_score
from data_writes import savecsvs,readcsv,savecsv

projection = 0


# WGS84 geographic coordinate system and Web Mercator coordinate system
# crs_WGS84 = CRS.from_epsg(4326)
# crs_WebMercator = CRS.from_epsg(3857)
# cell_size = 0.009330691929342804
# origin_level = 24
# EarthRadius = 6378137.0
# tile_size = 256

def create_folder(inputpath):
    &#34;&#34;&#34;
       This function is for creating folders

       Args:
           inputpath: The folder path

       Returns:
           True: Omitted
    &#34;&#34;&#34;
    if not os.path.exists(inputpath):
        os.makedirs(inputpath)

def file_names(inputpath):
    &#34;&#34;&#34;
       This function is for looping over files

       Args:
           inputpath: The folder path  to be looped over

       Returns:
           namelist: The files list
    &#34;&#34;&#34;
    namelist = []
    filePath = inputpath
    for i, j, k in os.walk(filePath):
        namelist.append([i, j, k])
    return namelist

# Get the file names in the source folder
def get_all_csv(data_path):
    &#34;&#34;&#34;
       This function is for getting all csv files

       Args:
           data_path: The folder path of storing the csv files

       Returns:
           all_csv: All the csv files
    &#34;&#34;&#34;

    excel_list = file_names(data_path)
    all_csv = []
    for i in range(len(excel_list)):
        folder_attribute = excel_list[i]
        if len(folder_attribute[2])&gt;0:
            for fileName in folder_attribute[2]:
                if fileName[-1] == &#39;v&#39;:
                    all_csv.append(fileName)
    return all_csv

#Coordinate conversion to wgs84
def projection2wgs84(lat, lon):
    &#34;&#34;&#34;
       This function is for coordinates conversion into  geographical ones

       Args:
           a: The coordinates of longitude
           b: The coordinates of latitude

       Returns:
           lon: The geographical coordinates of longitude
           lat: The geographical coordinates of latitude
    &#34;&#34;&#34;
    global projection
    crs_WGS84 = CRS.from_epsg(4326)
    crs_projection = CRS.from_epsg(projection)
    transformer = Transformer.from_crs(crs_projection, crs_WGS84)
    m, n = transformer.transform(lat, lon)
    return n, m


#Coordinate conversion from wgs84 to 2D projection
def wgs84toprojection(lat, lon):
    global projection
    &#34;&#34;&#34;
       This function is for coordinates conversion 

       Args:
           lat: The geographical coordinates of latitude
           lon: The geographical coordinates of longitude

       Returns:
           m: The coordinates of latitude after conversion
           n: The coordinates of longitude after conversion
    &#34;&#34;&#34;
    crs_WGS84 = CRS.from_epsg(4326)
    crs_projection = CRS.from_epsg(projection)
    transformer = Transformer.from_crs(crs_WGS84, crs_projection)
    m, n = transformer.transform(lat, lon)
    return n, m


# Data preprocessing: Coordinates conversion
def get_initial_data(x,y,date,length,projection1):
    global projection
    projection = projection1
    &#34;&#34;&#34;
       This function is for converting the geographical coordinates 

       Args:
           x: The geographical coordinates of latitude
           y: The geographical coordinates of longitude
           date: The observation date
           length: The length of the data
           projection1: The EPSG code

       Returns:
           initial_data: The coordinates after converting
    &#34;&#34;&#34;
    initial_data = []
    initial_data.append([&#34;LATITUDE&#34;, &#34;LONGITUDE&#34;, &#34;OBSERVATION DATE&#34;])
    for i in range(length):
        result = wgs84toprojection(x[i], y[i])
        initial_data.append([result[0], result[1], date[i]])

    return initial_data

#Data preprocessing: Interpolation for missing date
def interpolation(date,length,initial_data):
    &#34;&#34;&#34;
       This function is to finish interpolation for missing dates

       Args:
           date: The observation date
           length: The length of the data
           initial_data: The data after coordinates conversion

       Returns:
           initial_data: The data results after interpolation
    &#34;&#34;&#34;
    k = 43101
    lose_date = []
    now_date = []
    all_date = [i for i in range(k, k + 365)]
    for i in range(length):
        now_date.append(date[i])
    for i in all_date:
        if i not in now_date:
            lose_date.append(i)
    # print(lose_date)


    for lose in lose_date:
        x = []
        y = []
        for data in initial_data:
            if data[2] == &#34;OBSERVATION DATE&#34;:
                continue
            if 0 &lt; lose - int(data[2]) &lt;= 2:
                x.append(data[0])
                y.append(data[1])
        initial_data.append([sum(x) / len(x), sum(y) / len(y), lose])
    return initial_data

##Data preprocessing:Smooth the data by rolling window algorithm with window length=7
def rolling_window(initial_data,save_path,csv_name):
    &#34;&#34;&#34;
       This function is for rolling_window algorithm

       Args:
           initial_data: The data after interpolation
           save_path: The path for saving the result file
           csv_name: The species name being processed

       Returns:
           rolling_window_data_df: The data results after rolling_window
    &#34;&#34;&#34;
    Rolling_window_data = []
    Rolling_window_data.append([&#34;LATITUDE&#34;, &#34;LONGITUDE&#34;, &#34;OBSERVATION DATE&#34;])

    k = 43101
    for i in range(k, k + 365):
        for data in initial_data:
            if data[2] == &#34;OBSERVATION DATE&#34;:
                continue
            if -3 &lt; data[2] - i &lt;= 3:
                Rolling_window_data.append([data[0], data[1], i])

    # window_data_df = pd.DataFrame(window_data, columns=False)
    # window_data_df.to_csv(&#39;426.csv&#39;, index=False)
    Rolling_window_data_df = pd.DataFrame(Rolling_window_data[1:], columns=Rolling_window_data[0])
    Rolling_window_data_df.to_csv(os.path.join(save_path, csv_name.replace(&#39;.csv&#39;,&#39;&#39;), &#39;rolling_window_data.csv&#39;), index=False)
    return Rolling_window_data_df

#sldf() for outlier detection
def sldf(x):
    &#34;&#34;&#34;
       This function is for outlier detection based on sldf values

       Args:
           x: The input data

       Returns:
           result: The result after sldf outlier detection
    &#34;&#34;&#34;
    n = len(x)
    column = len(x[0])
    x_max = np.max(x)
    x_min = np.min(x)
    x_ = (x - x_min) / (x_max - x_min)
    k = 50
    lens = 1 / k
    position_x = np.ceil(x_ / lens)

    for i in range(len(position_x)):
        for j in range(len(position_x[0])):
            if position_x[i][j] == 0:
                position_x[i][j] = 1

    B = np.lexsort([position_x[:, 1], position_x[:, 0]])
    A = position_x[B, :]
    A = A.astype(int)
    count = np.zeros((k, k))
    for i in range(n):
        count[A[i][0] - 1][A[i][1] - 1] += 1
    max_count = np.max(count)

    q = 2
    q = q * max_count
    w = [0.5, 0.5]
    dist = np.zeros((n, n))
    for i in range(n):
        dist[:, i] = w[0] * ((x_[:, 0] - x_[i, 0]) ** 2) + w[1] * ((x_[:, 1] - x_[i, 1]) ** 2)
    dist = np.sqrt(dist)
    max_dist = np.max(dist)
    k = max_dist
    N = []
    for i in range(len(dist)):
        for j in range(len(dist[0])):
            Ni, Nj = j, i
            N.append((Ni, Nj))

    N = np.array(N)
    u = np.zeros(n)
    SLDR = np.zeros(n)
    N_i = N[:, 0]
    N_j = N[:, 1]

    for i in range(n):
        tmp = np.argwhere(N_j == i)
        tmp_E = int(max(tmp))
        tmp_S = int(min(tmp))
        tmp_N = N[tmp_S: tmp_E + 1, :]
        tmp_D = []
        for j in range(len(tmp_N)):
            a, b = tmp_N[j]
            tmp_D.append(dist[a, b])
        tmp_ji = tmp_E - tmp_S + 1
        u[i] = sum(tmp_D) / tmp_ji
        tmp_c = (tmp_D - u[i]) ** 2
        SLDR[i] = sum(tmp_c) / tmp_ji

    SLDIR = np.zeros(n)
    for i in range(n):
        tmp = np.argwhere(N_j == i)
        tmp_E = int(max(tmp))
        tmp_S = int(min(tmp))
        tmp = SLDR[N_i[tmp_S: tmp_E + 1]]
        SLDIR[i] = sum(tmp) / tmp_ji

    SLDF = SLDR / SLDIR
    # print(SLDF.shape, x.shape)
    selected_index = np.argsort(SLDF)[:int(0.8 * len(SLDF) + 1)]
    # print(selected_index.shape)
    SLDF_new = SLDF[selected_index]
    result = np.concatenate((x[selected_index], SLDF_new[:, np.newaxis]), axis=1)
    return result

#Data preprocessing:Outlier detectiobn through SLDF
def get_sldf(window_data_df,save_path,csv_name):
    &#34;&#34;&#34;
       This function is for saving the results after sldf outlier detection

       Args:
           window_data_df: The data after rolling_window
           save_path: The path for saving the result file
           csv_name: The species name being processed

       Returns:
           sldf_df: The data results after sldf outlier detection
    &#34;&#34;&#34;
    xall = window_data_df.values.astype(float)
    SLDF_all = np.zeros((0, 4))

    day_index = dict()
    day_index[43101] = 0
    for index, i in enumerate(xall[:, 2]):
        if i not in day_index:
            day_index[i] = index

    for day in range(1, 366):
        date = day + 43100
        if day != 365:
            temp = xall[day_index[date]:day_index[date + 1], :2]
        else:
            temp = xall[day_index[date]:, :2]
        outl = sldf(temp)
        t = date * np.ones((outl.shape[0], 1))
        outl = np.concatenate((outl, t), axis=1)
        SLDF_all = np.concatenate((SLDF_all, outl), axis=0)
    new_columns = [&#34;LATITUDE&#34;, &#34;LONGITUDE&#34;, &#34;SLDF&#34;, &#34;OBSERVATION DATE&#34;]

    SLDF_df = pd.DataFrame(SLDF_all, columns=new_columns)
    SLDF_df.to_csv(os.path.join(save_path, csv_name.replace(&#39;.csv&#39;,&#39;&#39;), &#39;sldf.csv&#39;), index=False)
    return SLDF_df

#Trajectory estimation: Get daily population centroids by Meanshift algorithm
def mean_shift(SLDF_df,save_path,csv_name):
    &#34;&#34;&#34;
       This function is for getting centroids of high-density subpopulations by Meanshift algorithm

       Args:
           SLDF_df: The data after sldf outlier detection
           save_path: The path for saving the result file
           csv_name: The species name being processed

        Returns:
           result: The data results after Meanshift clustering
    &#34;&#34;&#34;
    # datas = pd.read_excel(&#39;data/clean_window_data.xlsx&#39;)
    datas = SLDF_df.drop([&#39;SLDF&#39;], axis=1)
    result = []
    result.append([&#34;LATITUDE&#34;, &#34;LONGITUDE&#34;, &#34;OBSERVATION DATE&#34;])
    for date in tqdm(range(43101, 43466)):
    #for date in range(43101, 43119):
        #print(date)
        data = datas.loc[date == datas[&#39;OBSERVATION DATE&#39;]]  # .values.tolist()#[&#34;answer&#34;]
        data = data.iloc[:, :2]
        data = np.array(data)
        if len(data) == 0:
            continue

        ms = MeanShift()
        ms.fit(data)
        labels = ms.labels_
        cluster_centers = ms.cluster_centers_

        labels_unique = np.unique(labels)
        n_clusters = len(labels_unique)

        for c in cluster_centers:
            result.append([float(c[0]), float(c[1]), date])

        colors = cycle(&#39;bcmyk&#39;)
        if date % 10 == 0:
            for k, color in zip(range(n_clusters), colors):
                # current_member indicates true if the label is k and false if not
                current_member = labels == k
                cluster_center = cluster_centers[k]
                # Draw plots
                plt.plot(data[current_member, 0], data[current_member, 1], color + &#39;.&#39;)
                # Draw circles
                plt.plot(cluster_center[0], cluster_center[1], &#39;o&#39;,
                         markerfacecolor=color,
                         markeredgecolor=&#39;k&#39;,
                         markersize=14)

                plt.xlabel(&#39;Latitude(meter)&#39;)

                plt.ylabel(&#39;Longitude(meter)&#39;)
            # plt.show()
            plt.savefig(os.path.join(save_path, csv_name.replace(&#39;.csv&#39;, &#39;&#39;), &#39;centroids_{}.jpg&#39;.format(date)), dpi=1000)
            plt.close()
    return result

#Trajectory estimation: Group the daily population centroids according to the minimum distance principle
def group(csv_path,save_path,csv_name):
    &#34;&#34;&#34;
       This function is for grouping the daily subpopulation centroids based on the minimum distance

       Args:
           csv_path: The path for the data file after Meanshift algorithm
           save_path: The path for saving the result file
           csv_name: The species name being processed

       Returns:
           True: Omitted

    &#34;&#34;&#34;
    A1 = np.array([[0], [0]])
    A3 = np.array([[0], [0]])

    datas = pd.read_csv(csv_path)
    #datas = datas.iloc[1:, :]

    result_list = []
    for date in range(43101, 43466):
        data = datas.loc[date == datas[&#39;OBSERVATION DATE&#39;]]
        data = data.iloc[:, :2].values.tolist()
        A1 = np.hstack((A1, np.array(list(data)).T))
        A3 = np.hstack((A3, np.array([[int(len(data))], [A3[1, -1] + int(len(data))]])))

    A1 = np.delete(A1, 0, axis=1)
    A3 = np.delete(A3, 0, axis=1)

    np.save(&#34;A1.npy&#34;, A1)
    np.save(&#34;A3.npy&#34;, A3)

    # A1 = np.load(&#39;A1.npy&#39;)
    # A3 = np.load(&#39;A3.npy&#39;)

    p2 = 0
    N3 = A3.shape[1]
    LL4 = 0
    dddd = 0
    LL5 = 0
    LL6 = 0

    zhongjian = {}
    KKK2 = np.zeros((1, 10000))
    KKK3 = np.zeros((1, 10000))
    new1 = np.zeros((2, 1000))
    guiji = {}
    abc = np.zeros((10000, 10000), dtype=int)

#Traversal calculations of the centroid distance between two adjacent days in the annual circle
    for b1 in range(2, N3):
        if LL6 &gt; 0:
            LL1 = A3[1, b1 - 2]
            LL2 = A3[1, b1 - 1]
            LL3 = A3[1, b1]
            O1 = A3[0, b1 - 2]
            O2 = new2
            O3 = A3[0, b1]
            KK1 = A1[:, np.arange(LL4, LL1)]
            KK2 = new1
            KK3 = A1[:, np.arange(LL2, LL3)]
            LL4 = LL1
            LL5 = LL5 + 1
        if LL6 == 0:
            LL1 = A3[1, b1 - 2]
            LL2 = A3[1, b1 - 1]
            LL3 = A3[1, b1]
            O1 = A3[0, b1 - 2]
            O2 = A3[0, b1 - 1]
            O3 = A3[0, b1]
            KK1 = A1[:, np.arange(LL4, LL1)]
            KK2 = A1[:, np.arange(LL1, LL2)]
            KK3 = A1[:, np.arange(LL2, LL3)]
            LL4 = LL1
            LL5 = LL5 + 1

#Store centroid coordinates
        guodu1 = KK2.shape[1]
        for pp1 in range(1, guodu1 + 1):
            kk2 = KK2[:, pp1 - 1]
            kk2 = np.transpose(kk2)
            KKK2[:, np.arange(pp1 * 2 - 2, pp1 * 2)] = kk2
        guodu2 = KK3.shape[1]
        for pp1 in range(1, guodu2 + 1):
            kk3 = KK3[:, pp1 - 1]
            kk3 = np.transpose(kk3)
            KKK3[:, np.arange(pp1 * 2 - 2, pp1 * 2)] = kk3

#Perform centroid distance traversal calculation when the number of centroids on the later day is greater than the previous day
#The calculation order needs to consider from O2 to O3 and from O3 to O2 to ensure that all centroids in O3 can be connected.
        jl = np.zeros((100, 100))
        if O3 &gt; O2:
            new2 = O3
            dddd = dddd + 1
            for t1 in range(1, O2 + 1):
                for t2 in range(1, O3 + 1):
                    jl[t1 - 1, t2 - 1] = np.sqrt(
                        (KK2[0, t1 - 1] - KK3[0, t2 - 1]) ** 2 + (KK2[1, t1 - 1] - KK3[1, t2 - 1]) ** 2)
            index = np.argmin(jl[:O2, :O3], axis=1)
            for t3 in range(1, O2 + 1):
                aaa = int(index[t3 - 1] + 1)
                if dddd == 1:
                    shuju1 = np.vstack(
                        (KKK2[:, np.arange(t3 * 2 - 2, t3 * 2)], KKK3[:, np.arange(aaa * 2 - 2, aaa * 2)]))
                    new1[:, t3 - 1] = KK3[:, aaa - 1]
                    LL6 = LL6 + 1
                if dddd &gt; 1:
                    shuju1 = np.vstack((guiji[t3 - 1], KKK3[:, np.arange(aaa * 2 - 2, aaa * 2)]))
                    new1[:, t3 - 1] = KK3[:, aaa - 1]
                zhongjian[t3 - 1] = shuju1
                # zhongjian[t3-1][np.all(shuju1 == 0, axis=1),:].fill(0)
            jl = np.zeros((100, 100))
            for t1 in range(1, O3 + 1):
                for t2 in range(1, O2 + 1):
                    jl[t1 - 1, t2 - 1] = np.sqrt(
                        (KK3[0, t1 - 1] - KK2[0, t2 - 1]) ** 2 + (KK3[1, t1 - 1] - KK2[1, t2 - 1]) ** 2)
            index = np.argmin(jl[:O3, :O2], axis=1)
            XX = np.unique(index)
            nnp = O3 - O2
            nnn = 1
            for i in range(1, len(XX) + 1):
                m = (index == XX[i - 1]).nonzero()[0]
                if len(m) &gt;= 2:
                    abc[nnn - 1, 0] = XX[i - 1] + 1
                    abc[nnn - 1, 1] = len(m)
                    nnn = nnn + 1
                if len(m) &gt;= 2:
                    for nnc in range(1, nnp + 1):
                        if nnn - 1 &gt; 0:
                            aaa = int(index[abc[nnn - 2, 0]] + 1)
                        if nnn - 1 &gt; 1:
                            aaa = int(index[abc[nnn - 2, 0]] + 1)
                            nnn = nnn - 1
                        if dddd &gt; 1:
                            shuju1 = np.vstack((guiji[abc[nnn - 2, 0]], KKK3[:, np.arange(aaa * 2 - 2, aaa * 2)]))
                        if dddd == 1:
                            shuju1 = np.vstack((KKK2[:, np.arange(abc[nnn - 2, 0] * 2 - 2, abc[nnn - 2, 0] * 2)],
                                                KKK3[:, np.arange(aaa * 2 - 2, aaa * 2)]))
                        new1[:, O2 + nnc - 1] = KK3[:, aaa - 1]
                        zhongjian[O2 + nnc - 1] = shuju1
                        # zhongjian[O2 + nnc-1][np.all(shuju1 == 0,axis=1),:].fill(0)
            for t10 in range(0, O3):
                guiji[t10] = zhongjian[t10]

#Perform centroid distance traversal calculation when the number of centroids on the later day is less than the previous day

        if O3 &lt;= O2:
            new2 = O2
            dddd = dddd + 1
            for t1 in range(1, O2 + 1):
                for t2 in range(1, O3 + 1):
                    jl[t1 - 1, t2 - 1] = np.sqrt(
                        (KK2[0, t1 - 1] - KK3[0, t2 - 1]) ** 2 + (KK2[1, t1 - 1] - KK3[1, t2 - 1]) ** 2)
            index = np.argmin(jl[:O2, :O3], axis=1)
            for t3 in range(1, O2 + 1):
                aaa = int(index[t3 - 1] + 1)
                if dddd == 1:
                    shuju1 = np.vstack(
                        (KKK2[:, np.arange(t3 * 2 - 2, t3 * 2)], KKK3[:, np.arange(aaa * 2 - 2, aaa * 2)]))
                    new1[:, t3 - 1] = KK3[:, aaa - 1]
                    LL6 = LL6 + 1
                if dddd &gt; 1:
                    shuju1 = np.vstack((guiji[t3 - 1], KKK3[:, np.arange(aaa * 2 - 2, aaa * 2)]))
                    new1[:, t3 - 1] = KK3[:, aaa - 1]
                    LL6 = LL6 + 1
                guiji[t3 - 1] = shuju1
                # guiji[t3][np.all(shuju1 == 0, axis=1),:].fill(0)

    for key, value in guiji.items():
        value = np.hstack((np.array(value), np.arange(1, len(value) + 1).reshape((len(value), 1))))
        df1 = value.tolist()
        # df = pd.DataFrame(value)
        names = [[&#39;X&#39;, &#39;Y&#39;, &#39;date_index&#39;]] + df1
        # df.columns = names
        # df.to_excel(os.path.join(save_path, csv_name.replace(&#39;.csv&#39;,&#39;&#39;), &#39;ni_traj{}.xlsx&#39;.format(key + 1)), sheet_name=&#39;Sheet1&#39;, index=False)
        savecsvs(os.path.join(save_path, csv_name.replace(&#39;.csv&#39;,&#39;&#39;), &#39;group{}.csv&#39;.format(key + 1)),names)

#Fitting longitude and latitude with time repectively with GAM
def gam(save_path, csv_name, key):
    &#34;&#34;&#34;
       This function is for gam algorithm

       Args:
           save_path: The path for saving the result file
           csv_name: The species name being processed
           key: The number for file naming

       Returns:
           Lon: The longitude after GAM fitting
           Lat: The latitude after GAM fitting
    &#34;&#34;&#34;
    df = pd.read_csv(os.path.join(save_path, csv_name.replace(&#39;.csv&#39;, &#39;&#39;), &#39;group{}.csv&#39;.format(key + 1)))
    date = df[&#34;date_index&#34;]
    x = df[&#34;X&#34;]
    y = df[&#34;Y&#34;]
    xx = df[&#34;date_index&#34;]
    xx = xx + 43100


    gam_model_x = LinearGAM().fit(date, x)
    gam_model_y = LinearGAM().fit(date, y)

    predictions_x = gam_model_x.predict(date)
    predictions_y = gam_model_y.predict(date)

    # Draw the pictures
    plt.figure(figsize=(16, 8))
    plt.subplot(1, 2, 1)
    plt.scatter(xx, y, color=&#39;darkorange&#39;, label=&#39;data&#39;)
    plt.plot(xx, predictions_y, color=&#39;navy&#39;, lw=2, label=&#39;GAM&#39;)
    # plt.plot(X_all, y_gb_longitude_pred, color=&#39;c&#39;, lw=2, label=&#39;Gradient Boosting&#39;)
    plt.xlabel(&#39;Date&#39;)
    plt.ylabel(&#39;Longitude(meter)&#39;)
    #plt.title(&#39;Longitude&#39;)
    plt.legend()

    plt.subplot(1, 2, 2)
    plt.scatter(xx, x, color=&#39;darkorange&#39;, label=&#39;data&#39;)
    plt.plot(xx, predictions_x, color=&#39;navy&#39;, lw=2, label=&#39;GAM&#39;)
    # plt.plot(X_all, y_gb_latitude_pred, color=&#39;c&#39;, lw=2, label=&#39;Gradient Boosting&#39;)
    plt.xlabel(&#39;Date&#39;)
    plt.ylabel(&#39;Latitude(meter)&#39;)
    #plt.title(&#39;Latitude&#39;)
    plt.legend()
    plt.tight_layout()
    # plt.show()
    plt.savefig(os.path.join(save_path, csv_name.replace(&#39;.csv&#39;, &#39;&#39;), &#39;gam{}.jpg&#39;.format(key + 1)))
    plt.close()

    # Calculate the indexes
    mse_longitude = mean_squared_error(y, predictions_y)
    mse_latitude = mean_squared_error(x, predictions_x)

    rmse_longitude = np.sqrt(mse_longitude)
    rmse_latitude = np.sqrt(mse_latitude)

    r2_score_longitude = r2_score(y, predictions_y)
    r2_score_latitude = r2_score(x, predictions_x)
    try:
        readcsv(save_path + csv_name.replace(&#39;.csv&#39;, &#39;&#39;) + &#39;/{}.csv&#39;.format(&#39;evaluation_index&#39;))
    except:
        savecsv(save_path + csv_name.replace(&#39;.csv&#39;, &#39;&#39;) + &#39;/{}.csv&#39;.format(&#39;evaluation_index&#39;),
                [&#39;mse_longitude&#39;, &#39;mse_latitude&#39;, &#39;rmse_longitude&#39;, &#39;rmse_latitude&#39;, &#39;r2_score_longitude&#39;,
                 &#39;r2_score_latitude&#39;])
    savecsv(save_path + csv_name.replace(&#39;.csv&#39;, &#39;&#39;) + &#39;/{}.csv&#39;.format(&#39;evaluation_index&#39;),
            [mse_longitude, mse_latitude, rmse_longitude, rmse_latitude, r2_score_longitude, r2_score_latitude])

    datas = [[&#34;X*&#34;, &#34;Y*&#34;, &#34;date_index&#34;]]
    # datas = []
    for i in range(len(x)):
        datas.append([predictions_x[i], predictions_y[i], date[i]])
    # data_write(os.path.join(save_path, csv_name.replace(&#39;.csv&#39;, &#39;&#39;), &#39;result_{}.xls&#39;.format(key + 1)), datas)
    savecsvs(os.path.join(save_path, csv_name.replace(&#39;.csv&#39;, &#39;&#39;), &#39;fitting_result{}.csv&#39;.format(key + 1)), datas)

    # Coordinate conversion to wgs84
    Lon,Lat = projection2wgs84(predictions_y,predictions_x)
    return Lon, Lat


#Fitting longitude and latitude with time repectively with RandomForests
def randomforest(save_path, csv_name,key):
    &#34;&#34;&#34;
       This function is for Random forests algorithm

       Args:
           save_path: The path for saving the result file
           csv_name: The species name being processed
           key: The number for file naming

       Returns:
           Lon: The longitude after Random Forests algorithm
           Lat: The latitude after Random Forests algorithm

    &#34;&#34;&#34;
    df = pd.read_csv(os.path.join(save_path, csv_name.replace(&#39;.csv&#39;, &#39;&#39;), &#39;group{}.csv&#39;.format(key + 1)))
    date = df[&#34;date_index&#34;]
    xx = df[&#34;date_index&#34;]
    xx = xx + 43100

    X = df[[&#39;date_index&#39;]]  # Features (date)
    y_longitude = df[&#39;Y&#39;]  # Target variable (longitude)
    y_latitude = df[&#39;X&#39;]  # Target variable (latitude)

    # Train the model
    rf_longitude = RandomForestRegressor(n_estimators=100, random_state=42)
    rf_latitude = RandomForestRegressor(n_estimators=100, random_state=42)
    rf_longitude.fit(X, y_longitude)
    rf_latitude.fit(X, y_latitude)

    y_rf_longitude_pred = rf_longitude.predict(X)
    y_rf_latitude_pred = rf_latitude.predict(X)


    # Draw the pictures
    plt.figure(figsize=(16, 8))
    plt.subplot(1, 2, 1)
    plt.scatter(xx, y_longitude, color=&#39;darkorange&#39;, label=&#39;data&#39;)
    plt.plot(xx, y_rf_longitude_pred, color=&#39;navy&#39;, lw=2, label=&#39;Random Forest&#39;)
    # plt.plot(X_all, y_gb_longitude_pred, color=&#39;c&#39;, lw=2, label=&#39;Gradient Boosting&#39;)
    plt.xlabel(&#39;Date&#39;)
    plt.ylabel(&#39;Longitude(meter)&#39;)
    #plt.title(&#39;Longitude&#39;)
    plt.legend()

    plt.subplot(1, 2, 2)
    plt.scatter(xx, y_latitude, color=&#39;darkorange&#39;, label=&#39;data&#39;)
    plt.plot(xx, y_rf_latitude_pred, color=&#39;navy&#39;, lw=2, label=&#39;Random Forest&#39;)
    # plt.plot(X_all, y_gb_latitude_pred, color=&#39;c&#39;, lw=2, label=&#39;Gradient Boosting&#39;)
    plt.xlabel(&#39;Date&#39;)
    plt.ylabel(&#39;Latitude(meter)&#39;)
    #plt.title(&#39;Latitude&#39;)
    plt.legend()
    plt.tight_layout()
    # plt.show()
    plt.savefig(os.path.join(save_path, csv_name.replace(&#39;.csv&#39;, &#39;&#39;), &#39;randomforest{}.jpg&#39;.format(key + 1)))
    plt.close()


    # Calculate the indexes
    mse_longitude = mean_squared_error(y_longitude, y_rf_longitude_pred)
    mse_latitude = mean_squared_error(y_latitude, y_rf_latitude_pred)

    rmse_longitude = np.sqrt(mse_longitude)
    rmse_latitude = np.sqrt(mse_latitude)

    r2_score_longitude = r2_score(y_longitude, y_rf_longitude_pred)
    r2_score_latitude = r2_score(y_latitude, y_rf_latitude_pred)
    try:
        readcsv(save_path + csv_name.replace(&#39;.csv&#39;,&#39;&#39;) + &#39;/{}.csv&#39;.format(&#39;evaluation_index&#39;))
    except:
        savecsv(save_path + csv_name.replace(&#39;.csv&#39;, &#39;&#39;) + &#39;/{}.csv&#39;.format(&#39;evaluation_index&#39;),
                [&#39;mse_longitude&#39;, &#39;mse_latitude&#39;, &#39;rmse_longitude&#39;, &#39;rmse_latitude&#39;, &#39;r2_score_longitude&#39;, &#39;r2_score_latitude&#39;])
    savecsv(save_path + csv_name.replace(&#39;.csv&#39;,&#39;&#39;) + &#39;/{}.csv&#39;.format(&#39;evaluation_index&#39;),
            [mse_longitude,mse_latitude,rmse_longitude,rmse_latitude,r2_score_longitude,r2_score_latitude])


    datas = [[&#34;X*&#34;, &#34;Y*&#34;,&#34;date_index&#34;]]
    # datas = []
    for i in range(len(date)):
        datas.append([y_rf_latitude_pred[i], y_rf_longitude_pred[i],date[i]])
    # data_write(os.path.join(save_path, csv_name.replace(&#39;.csv&#39;,&#39;&#39;), &#39;result_{}.xls&#39;.format(key + 1)), datas)
    savecsvs(os.path.join(save_path, csv_name.replace(&#39;.csv&#39;,&#39;&#39;), &#39;fitting_result{}.csv&#39;.format(key + 1)), datas)

#Coordinate conversion to wgs84

    Lon, Lat = projection2wgs84(y_rf_longitude_pred, y_rf_latitude_pred)
    return Lon, Lat

#Fitting longitude and latitude with time repectively with KNN
def knn(save_path, csv_name,key):
    &#34;&#34;&#34;
       This function is for KNN algorithm

       Args:
           save_path: The path for saving the result file
           csv_name: The species name being processed
           key: The number for file naming

       Returns:
           Lon: The longitude after KNN fitting
           Lat: The latitude after KNN fitting

    &#34;&#34;&#34;

    df = pd.read_csv(os.path.join(save_path, csv_name.replace(&#39;.csv&#39;, &#39;&#39;), &#39;group{}.csv&#39;.format(key + 1)))
    date = df[&#34;date_index&#34;]
    xx = df[&#34;date_index&#34;]
    xx = xx + 43100

    X = df[[&#39;date_index&#39;]]  # Features (date)
    y_longitude = df[&#39;Y&#39;]  # Target variable (longitude)
    y_latitude = df[&#39;X&#39;]  # Target variable (latitude)


    # Train the model
    knn_longitude = KNeighborsRegressor(n_neighbors=5)
    knn_latitude = KNeighborsRegressor(n_neighbors=5)
    knn_longitude.fit(X, y_longitude)
    knn_latitude.fit(X, y_latitude)

    y_knn_longitude_pred = knn_longitude.predict(X)
    y_knn_latitude_pred = knn_latitude.predict(X)

    # Draw the pictures
    plt.figure(figsize=(16, 8))
    plt.subplot(1, 2, 1)
    plt.scatter(xx, y_longitude, color=&#39;darkorange&#39;, label=&#39;data&#39;)
    plt.plot(xx, y_knn_longitude_pred, color=&#39;navy&#39;, lw=2, label=&#39;KNN&#39;)
    # plt.plot(X_all, y_gb_longitude_pred, color=&#39;c&#39;, lw=2, label=&#39;Gradient Boosting&#39;)
    plt.xlabel(&#39;Date&#39;)
    plt.ylabel(&#39;Longitude(meter)&#39;)
    #plt.title(&#39;Longitude&#39;)
    plt.legend()

    plt.subplot(1, 2, 2)
    plt.scatter(xx, y_latitude, color=&#39;darkorange&#39;, label=&#39;data&#39;)
    plt.plot(xx, y_knn_latitude_pred, color=&#39;navy&#39;, lw=2, label=&#39;KNN&#39;)
    # plt.plot(X_all, y_gb_latitude_pred, color=&#39;c&#39;, lw=2, label=&#39;Gradient Boosting&#39;)
    plt.xlabel(&#39;Date&#39;)
    plt.ylabel(&#39;Latitude(meter)&#39;)
    #plt.title(&#39;Latitude&#39;)
    plt.legend()
    plt.tight_layout()
    # plt.show()
    plt.savefig(os.path.join(save_path, csv_name.replace(&#39;.csv&#39;, &#39;&#39;), &#39;KNN{}.jpg&#39;.format(key + 1)))
    plt.close()

    # Calculate the indexes
    mse_longitude = mean_squared_error(y_longitude, y_knn_longitude_pred)
    mse_latitude = mean_squared_error(y_latitude, y_knn_latitude_pred)

    rmse_longitude = np.sqrt(mse_longitude)
    rmse_latitude = np.sqrt(mse_latitude)

    r2_score_longitude = r2_score(y_longitude, y_knn_longitude_pred)
    r2_score_latitude = r2_score(y_latitude, y_knn_latitude_pred)
    try:
        readcsv(save_path + csv_name.replace(&#39;.csv&#39;, &#39;&#39;) + &#39;/{}.csv&#39;.format(&#39;evaluation_index&#39;))
    except:
        savecsv(save_path + csv_name.replace(&#39;.csv&#39;, &#39;&#39;) + &#39;/{}.csv&#39;.format(&#39;evaluation_index&#39;),
                [&#39;mse_longitude&#39;, &#39;mse_latitude&#39;, &#39;rmse_longitude&#39;, &#39;rmse_latitude&#39;, &#39;r2_score_longitude&#39;,
                 &#39;r2_score_latitude&#39;])
    savecsv(save_path + csv_name.replace(&#39;.csv&#39;, &#39;&#39;) + &#39;/{}.csv&#39;.format(&#39;evaluation_index&#39;),
            [mse_longitude, mse_latitude, rmse_longitude, rmse_latitude, r2_score_longitude, r2_score_latitude])


    datas = [[&#34;X*&#34;, &#34;Y*&#34;,&#34;date_index&#34;]]
    # datas = []
    for i in range(len(date)):
        datas.append([y_knn_latitude_pred[i], y_knn_longitude_pred[i],date[i]])
    # data_write(os.path.join(save_path, csv_name.replace(&#39;.csv&#39;,&#39;&#39;), &#39;result_{}.xls&#39;.format(key + 1)), datas)
    savecsvs(os.path.join(save_path, csv_name.replace(&#39;.csv&#39;,&#39;&#39;), &#39;fitting_result{}.csv&#39;.format(key + 1)), datas)

#Coordinate conversion to wgs84

    Lon, Lat = projection2wgs84(y_knn_longitude_pred, y_knn_latitude_pred)
    return Lon, Lat

#Trajectory estimation: Show the estimation results on the map
def map_1(save_path,csv_name,type_name):
    &#34;&#34;&#34;
       This function is for showing the trajectories on the map

       Args:
           save_path: The path for storing the result figures
           csv_name: The name of the species to be processed
           type_name: The fitting model chosen for centroids fitting

       Returns:
           True: Omitted

    &#34;&#34;&#34;
    # plt.rcParams[&#39;figure.figsize&#39;] = (28, 8)
    # plt.show()

    excel_list = os.listdir(os.path.join(save_path, csv_name.replace(&#39;.csv&#39;, &#39;&#39;)))
    excel_list1 = []
    for csv_excel in excel_list:
        if &#39;group&#39; in csv_excel:
            excel_list1.append(csv_excel)

    LON = []
    LAT = []
    for i in range(len(excel_list1)):
        if type_name == &#39;gam&#39;:
            Lon, Lat = gam(save_path, csv_name, i)
        elif type_name == &#39;randomforest&#39;:
            Lon, Lat = randomforest(save_path, csv_name, i)
        elif type_name == &#39;knn&#39;:
            Lon, Lat = knn(save_path, csv_name, i)

        LON.append(Lon)
        LAT.append(Lat)

    m = Basemap(llcrnrlat=-60, urcrnrlat=90, llcrnrlon=-180, urcrnrlon=-20)  # Instantiate a map
    m.drawcoastlines()  # Draw the coastline
    m.drawmapboundary(fill_color=&#39;white&#39;)
    m.fillcontinents(lake_color=&#39;white&#39;)  # Draw the continents and fill them in white

    parallels = np.arange(-90., 90., 10.)  # Draw latitudes with ranges [-90,90] and intervals of 10
    m.drawparallels(parallels, labels=[False, True, True, False], color=&#39;none&#39;)
    meridians = np.arange(-180., 180., 20.)  # Draw the longitude with a range of [-180,180] and an interval of 10
    m.drawmeridians(meridians, labels=[True, False, False, True], color=&#39;none&#39;)
    for doc in range(0, len(LON)):
        colorMap = [&#39;red&#39;, &#39;darkorange&#39;, &#39;gold&#39;, &#39;greenyellow&#39;, &#39;pink&#39;, &#39;limegreen&#39;, &#39;mediumturquoise&#39;,
                    &#39;dodgerblue&#39;,
                    &#39;navy&#39;, &#39;blue&#39;, &#39;mediumorchid&#39;, &#39;fuchsia&#39;]
        # Show labels
        label = [&#39;January&#39;, &#39;February&#39;, &#39;March&#39;, &#39;April&#39;, &#39;May&#39;, &#39;June&#39;, &#39;July&#39;, &#39;August&#39;, &#39;September&#39;, &#39;October&#39;,
                 &#39;November&#39;, &#39;December&#39;]

        marker = [&#39;x&#39;, &#39;.&#39;, &#39;o&#39;, &#39;|&#39;, &#39;*&#39;, &#39;.&#39;, &#39;&lt;&#39;, &#39;&gt;&#39;, &#39;,&#39;, &#39;.&#39;, &#39;.&#39;, &#39;v&#39;, &#39;x&#39;, &#39;o&#39;, &#39;|&#39;, &#39;*&#39;, &#39;&lt;&#39;, &#39;^&#39;, &#39;.&#39;, &#39;*&#39;, &#39;v&#39;, &#39;*&#39;, &#39;,&#39;, &#39;y&#39;, &#39;.&#39;, &#39;.&#39;, &#39;.&#39;, &#39;.&#39;]
        j = 0
        # print(len(lon))
        flag = True


        for i in range(0, len(LON[doc]) - 30, 30):
            # print(i)
            if doc == 0:
                m.plot(LON[doc][i:i + 30], LAT[doc][i:i + 30], marker=marker[doc], linewidth=0.4,
                       color=colorMap[j],
                       markersize=0.5, label=label[
                        j])
                # plt.show()
                j += 1
                if j == 12:
                    j = 0
                    if flag:
                        plt.legend(loc=&#39;lower left&#39;, shadow=True)
                        flag = False
                    continue
            else:
                m.plot(LON[doc][i:i + 30], LAT[doc][i:i + 30], marker=marker[doc], linewidth=0.4,
                       color=colorMap[j],
                       markersize=0.5)
                # plt.show()
                j += 1
                if j == 12:
                    j = 0
                    if flag:
                        plt.legend(loc=&#39;lower left&#39;, shadow=True)
                        flag = False
                    continue

    plt.xlabel(&#39;Lon&#39;, labelpad=10)
    plt.ylabel(&#39;Lat&#39;)
    plt.savefig(os.path.join(save_path, csv_name.replace(&#39;.csv&#39;, &#39;&#39;), &#39;trajectories.jpg&#39;), dpi=1000)
    # plt.show()
    plt.close()</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="came.Part_2_functions_for_eachstep.create_folder"><code class="name flex">
<span>def <span class="ident">create_folder</span></span>(<span>inputpath)</span>
</code></dt>
<dd>
<div class="desc"><p>This function is for creating folders</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>inputpath</code></strong></dt>
<dd>The folder path</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>True</code></dt>
<dd>Omitted</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def create_folder(inputpath):
    &#34;&#34;&#34;
       This function is for creating folders

       Args:
           inputpath: The folder path

       Returns:
           True: Omitted
    &#34;&#34;&#34;
    if not os.path.exists(inputpath):
        os.makedirs(inputpath)</code></pre>
</details>
</dd>
<dt id="came.Part_2_functions_for_eachstep.file_names"><code class="name flex">
<span>def <span class="ident">file_names</span></span>(<span>inputpath)</span>
</code></dt>
<dd>
<div class="desc"><p>This function is for looping over files</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>inputpath</code></strong></dt>
<dd>The folder path
to be looped over</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>namelist</code></dt>
<dd>The files list</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def file_names(inputpath):
    &#34;&#34;&#34;
       This function is for looping over files

       Args:
           inputpath: The folder path  to be looped over

       Returns:
           namelist: The files list
    &#34;&#34;&#34;
    namelist = []
    filePath = inputpath
    for i, j, k in os.walk(filePath):
        namelist.append([i, j, k])
    return namelist</code></pre>
</details>
</dd>
<dt id="came.Part_2_functions_for_eachstep.gam"><code class="name flex">
<span>def <span class="ident">gam</span></span>(<span>save_path, csv_name, key)</span>
</code></dt>
<dd>
<div class="desc"><p>This function is for gam algorithm</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>save_path</code></strong></dt>
<dd>The path for saving the result file</dd>
<dt><strong><code>csv_name</code></strong></dt>
<dd>The species name being processed</dd>
<dt><strong><code>key</code></strong></dt>
<dd>The number for file naming</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>Lon</code></dt>
<dd>The longitude after GAM fitting</dd>
<dt><code>Lat</code></dt>
<dd>The latitude after GAM fitting</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def gam(save_path, csv_name, key):
    &#34;&#34;&#34;
       This function is for gam algorithm

       Args:
           save_path: The path for saving the result file
           csv_name: The species name being processed
           key: The number for file naming

       Returns:
           Lon: The longitude after GAM fitting
           Lat: The latitude after GAM fitting
    &#34;&#34;&#34;
    df = pd.read_csv(os.path.join(save_path, csv_name.replace(&#39;.csv&#39;, &#39;&#39;), &#39;group{}.csv&#39;.format(key + 1)))
    date = df[&#34;date_index&#34;]
    x = df[&#34;X&#34;]
    y = df[&#34;Y&#34;]
    xx = df[&#34;date_index&#34;]
    xx = xx + 43100


    gam_model_x = LinearGAM().fit(date, x)
    gam_model_y = LinearGAM().fit(date, y)

    predictions_x = gam_model_x.predict(date)
    predictions_y = gam_model_y.predict(date)

    # Draw the pictures
    plt.figure(figsize=(16, 8))
    plt.subplot(1, 2, 1)
    plt.scatter(xx, y, color=&#39;darkorange&#39;, label=&#39;data&#39;)
    plt.plot(xx, predictions_y, color=&#39;navy&#39;, lw=2, label=&#39;GAM&#39;)
    # plt.plot(X_all, y_gb_longitude_pred, color=&#39;c&#39;, lw=2, label=&#39;Gradient Boosting&#39;)
    plt.xlabel(&#39;Date&#39;)
    plt.ylabel(&#39;Longitude(meter)&#39;)
    #plt.title(&#39;Longitude&#39;)
    plt.legend()

    plt.subplot(1, 2, 2)
    plt.scatter(xx, x, color=&#39;darkorange&#39;, label=&#39;data&#39;)
    plt.plot(xx, predictions_x, color=&#39;navy&#39;, lw=2, label=&#39;GAM&#39;)
    # plt.plot(X_all, y_gb_latitude_pred, color=&#39;c&#39;, lw=2, label=&#39;Gradient Boosting&#39;)
    plt.xlabel(&#39;Date&#39;)
    plt.ylabel(&#39;Latitude(meter)&#39;)
    #plt.title(&#39;Latitude&#39;)
    plt.legend()
    plt.tight_layout()
    # plt.show()
    plt.savefig(os.path.join(save_path, csv_name.replace(&#39;.csv&#39;, &#39;&#39;), &#39;gam{}.jpg&#39;.format(key + 1)))
    plt.close()

    # Calculate the indexes
    mse_longitude = mean_squared_error(y, predictions_y)
    mse_latitude = mean_squared_error(x, predictions_x)

    rmse_longitude = np.sqrt(mse_longitude)
    rmse_latitude = np.sqrt(mse_latitude)

    r2_score_longitude = r2_score(y, predictions_y)
    r2_score_latitude = r2_score(x, predictions_x)
    try:
        readcsv(save_path + csv_name.replace(&#39;.csv&#39;, &#39;&#39;) + &#39;/{}.csv&#39;.format(&#39;evaluation_index&#39;))
    except:
        savecsv(save_path + csv_name.replace(&#39;.csv&#39;, &#39;&#39;) + &#39;/{}.csv&#39;.format(&#39;evaluation_index&#39;),
                [&#39;mse_longitude&#39;, &#39;mse_latitude&#39;, &#39;rmse_longitude&#39;, &#39;rmse_latitude&#39;, &#39;r2_score_longitude&#39;,
                 &#39;r2_score_latitude&#39;])
    savecsv(save_path + csv_name.replace(&#39;.csv&#39;, &#39;&#39;) + &#39;/{}.csv&#39;.format(&#39;evaluation_index&#39;),
            [mse_longitude, mse_latitude, rmse_longitude, rmse_latitude, r2_score_longitude, r2_score_latitude])

    datas = [[&#34;X*&#34;, &#34;Y*&#34;, &#34;date_index&#34;]]
    # datas = []
    for i in range(len(x)):
        datas.append([predictions_x[i], predictions_y[i], date[i]])
    # data_write(os.path.join(save_path, csv_name.replace(&#39;.csv&#39;, &#39;&#39;), &#39;result_{}.xls&#39;.format(key + 1)), datas)
    savecsvs(os.path.join(save_path, csv_name.replace(&#39;.csv&#39;, &#39;&#39;), &#39;fitting_result{}.csv&#39;.format(key + 1)), datas)

    # Coordinate conversion to wgs84
    Lon,Lat = projection2wgs84(predictions_y,predictions_x)
    return Lon, Lat</code></pre>
</details>
</dd>
<dt id="came.Part_2_functions_for_eachstep.get_all_csv"><code class="name flex">
<span>def <span class="ident">get_all_csv</span></span>(<span>data_path)</span>
</code></dt>
<dd>
<div class="desc"><p>This function is for getting all csv files</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>data_path</code></strong></dt>
<dd>The folder path of storing the csv files</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>all_csv</code></dt>
<dd>All the csv files</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_all_csv(data_path):
    &#34;&#34;&#34;
       This function is for getting all csv files

       Args:
           data_path: The folder path of storing the csv files

       Returns:
           all_csv: All the csv files
    &#34;&#34;&#34;

    excel_list = file_names(data_path)
    all_csv = []
    for i in range(len(excel_list)):
        folder_attribute = excel_list[i]
        if len(folder_attribute[2])&gt;0:
            for fileName in folder_attribute[2]:
                if fileName[-1] == &#39;v&#39;:
                    all_csv.append(fileName)
    return all_csv</code></pre>
</details>
</dd>
<dt id="came.Part_2_functions_for_eachstep.get_initial_data"><code class="name flex">
<span>def <span class="ident">get_initial_data</span></span>(<span>x, y, date, length, projection1)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_initial_data(x,y,date,length,projection1):
    global projection
    projection = projection1
    &#34;&#34;&#34;
       This function is for converting the geographical coordinates 

       Args:
           x: The geographical coordinates of latitude
           y: The geographical coordinates of longitude
           date: The observation date
           length: The length of the data
           projection1: The EPSG code

       Returns:
           initial_data: The coordinates after converting
    &#34;&#34;&#34;
    initial_data = []
    initial_data.append([&#34;LATITUDE&#34;, &#34;LONGITUDE&#34;, &#34;OBSERVATION DATE&#34;])
    for i in range(length):
        result = wgs84toprojection(x[i], y[i])
        initial_data.append([result[0], result[1], date[i]])

    return initial_data</code></pre>
</details>
</dd>
<dt id="came.Part_2_functions_for_eachstep.get_sldf"><code class="name flex">
<span>def <span class="ident">get_sldf</span></span>(<span>window_data_df, save_path, csv_name)</span>
</code></dt>
<dd>
<div class="desc"><p>This function is for saving the results after sldf outlier detection</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>window_data_df</code></strong></dt>
<dd>The data after rolling_window</dd>
<dt><strong><code>save_path</code></strong></dt>
<dd>The path for saving the result file</dd>
<dt><strong><code>csv_name</code></strong></dt>
<dd>The species name being processed</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>sldf_df</code></dt>
<dd>The data results after sldf outlier detection</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_sldf(window_data_df,save_path,csv_name):
    &#34;&#34;&#34;
       This function is for saving the results after sldf outlier detection

       Args:
           window_data_df: The data after rolling_window
           save_path: The path for saving the result file
           csv_name: The species name being processed

       Returns:
           sldf_df: The data results after sldf outlier detection
    &#34;&#34;&#34;
    xall = window_data_df.values.astype(float)
    SLDF_all = np.zeros((0, 4))

    day_index = dict()
    day_index[43101] = 0
    for index, i in enumerate(xall[:, 2]):
        if i not in day_index:
            day_index[i] = index

    for day in range(1, 366):
        date = day + 43100
        if day != 365:
            temp = xall[day_index[date]:day_index[date + 1], :2]
        else:
            temp = xall[day_index[date]:, :2]
        outl = sldf(temp)
        t = date * np.ones((outl.shape[0], 1))
        outl = np.concatenate((outl, t), axis=1)
        SLDF_all = np.concatenate((SLDF_all, outl), axis=0)
    new_columns = [&#34;LATITUDE&#34;, &#34;LONGITUDE&#34;, &#34;SLDF&#34;, &#34;OBSERVATION DATE&#34;]

    SLDF_df = pd.DataFrame(SLDF_all, columns=new_columns)
    SLDF_df.to_csv(os.path.join(save_path, csv_name.replace(&#39;.csv&#39;,&#39;&#39;), &#39;sldf.csv&#39;), index=False)
    return SLDF_df</code></pre>
</details>
</dd>
<dt id="came.Part_2_functions_for_eachstep.group"><code class="name flex">
<span>def <span class="ident">group</span></span>(<span>csv_path, save_path, csv_name)</span>
</code></dt>
<dd>
<div class="desc"><p>This function is for grouping the daily subpopulation centroids based on the minimum distance</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>csv_path</code></strong></dt>
<dd>The path for the data file after Meanshift algorithm</dd>
<dt><strong><code>save_path</code></strong></dt>
<dd>The path for saving the result file</dd>
<dt><strong><code>csv_name</code></strong></dt>
<dd>The species name being processed</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>True</code></dt>
<dd>Omitted</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def group(csv_path,save_path,csv_name):
    &#34;&#34;&#34;
       This function is for grouping the daily subpopulation centroids based on the minimum distance

       Args:
           csv_path: The path for the data file after Meanshift algorithm
           save_path: The path for saving the result file
           csv_name: The species name being processed

       Returns:
           True: Omitted

    &#34;&#34;&#34;
    A1 = np.array([[0], [0]])
    A3 = np.array([[0], [0]])

    datas = pd.read_csv(csv_path)
    #datas = datas.iloc[1:, :]

    result_list = []
    for date in range(43101, 43466):
        data = datas.loc[date == datas[&#39;OBSERVATION DATE&#39;]]
        data = data.iloc[:, :2].values.tolist()
        A1 = np.hstack((A1, np.array(list(data)).T))
        A3 = np.hstack((A3, np.array([[int(len(data))], [A3[1, -1] + int(len(data))]])))

    A1 = np.delete(A1, 0, axis=1)
    A3 = np.delete(A3, 0, axis=1)

    np.save(&#34;A1.npy&#34;, A1)
    np.save(&#34;A3.npy&#34;, A3)

    # A1 = np.load(&#39;A1.npy&#39;)
    # A3 = np.load(&#39;A3.npy&#39;)

    p2 = 0
    N3 = A3.shape[1]
    LL4 = 0
    dddd = 0
    LL5 = 0
    LL6 = 0

    zhongjian = {}
    KKK2 = np.zeros((1, 10000))
    KKK3 = np.zeros((1, 10000))
    new1 = np.zeros((2, 1000))
    guiji = {}
    abc = np.zeros((10000, 10000), dtype=int)

#Traversal calculations of the centroid distance between two adjacent days in the annual circle
    for b1 in range(2, N3):
        if LL6 &gt; 0:
            LL1 = A3[1, b1 - 2]
            LL2 = A3[1, b1 - 1]
            LL3 = A3[1, b1]
            O1 = A3[0, b1 - 2]
            O2 = new2
            O3 = A3[0, b1]
            KK1 = A1[:, np.arange(LL4, LL1)]
            KK2 = new1
            KK3 = A1[:, np.arange(LL2, LL3)]
            LL4 = LL1
            LL5 = LL5 + 1
        if LL6 == 0:
            LL1 = A3[1, b1 - 2]
            LL2 = A3[1, b1 - 1]
            LL3 = A3[1, b1]
            O1 = A3[0, b1 - 2]
            O2 = A3[0, b1 - 1]
            O3 = A3[0, b1]
            KK1 = A1[:, np.arange(LL4, LL1)]
            KK2 = A1[:, np.arange(LL1, LL2)]
            KK3 = A1[:, np.arange(LL2, LL3)]
            LL4 = LL1
            LL5 = LL5 + 1

#Store centroid coordinates
        guodu1 = KK2.shape[1]
        for pp1 in range(1, guodu1 + 1):
            kk2 = KK2[:, pp1 - 1]
            kk2 = np.transpose(kk2)
            KKK2[:, np.arange(pp1 * 2 - 2, pp1 * 2)] = kk2
        guodu2 = KK3.shape[1]
        for pp1 in range(1, guodu2 + 1):
            kk3 = KK3[:, pp1 - 1]
            kk3 = np.transpose(kk3)
            KKK3[:, np.arange(pp1 * 2 - 2, pp1 * 2)] = kk3

#Perform centroid distance traversal calculation when the number of centroids on the later day is greater than the previous day
#The calculation order needs to consider from O2 to O3 and from O3 to O2 to ensure that all centroids in O3 can be connected.
        jl = np.zeros((100, 100))
        if O3 &gt; O2:
            new2 = O3
            dddd = dddd + 1
            for t1 in range(1, O2 + 1):
                for t2 in range(1, O3 + 1):
                    jl[t1 - 1, t2 - 1] = np.sqrt(
                        (KK2[0, t1 - 1] - KK3[0, t2 - 1]) ** 2 + (KK2[1, t1 - 1] - KK3[1, t2 - 1]) ** 2)
            index = np.argmin(jl[:O2, :O3], axis=1)
            for t3 in range(1, O2 + 1):
                aaa = int(index[t3 - 1] + 1)
                if dddd == 1:
                    shuju1 = np.vstack(
                        (KKK2[:, np.arange(t3 * 2 - 2, t3 * 2)], KKK3[:, np.arange(aaa * 2 - 2, aaa * 2)]))
                    new1[:, t3 - 1] = KK3[:, aaa - 1]
                    LL6 = LL6 + 1
                if dddd &gt; 1:
                    shuju1 = np.vstack((guiji[t3 - 1], KKK3[:, np.arange(aaa * 2 - 2, aaa * 2)]))
                    new1[:, t3 - 1] = KK3[:, aaa - 1]
                zhongjian[t3 - 1] = shuju1
                # zhongjian[t3-1][np.all(shuju1 == 0, axis=1),:].fill(0)
            jl = np.zeros((100, 100))
            for t1 in range(1, O3 + 1):
                for t2 in range(1, O2 + 1):
                    jl[t1 - 1, t2 - 1] = np.sqrt(
                        (KK3[0, t1 - 1] - KK2[0, t2 - 1]) ** 2 + (KK3[1, t1 - 1] - KK2[1, t2 - 1]) ** 2)
            index = np.argmin(jl[:O3, :O2], axis=1)
            XX = np.unique(index)
            nnp = O3 - O2
            nnn = 1
            for i in range(1, len(XX) + 1):
                m = (index == XX[i - 1]).nonzero()[0]
                if len(m) &gt;= 2:
                    abc[nnn - 1, 0] = XX[i - 1] + 1
                    abc[nnn - 1, 1] = len(m)
                    nnn = nnn + 1
                if len(m) &gt;= 2:
                    for nnc in range(1, nnp + 1):
                        if nnn - 1 &gt; 0:
                            aaa = int(index[abc[nnn - 2, 0]] + 1)
                        if nnn - 1 &gt; 1:
                            aaa = int(index[abc[nnn - 2, 0]] + 1)
                            nnn = nnn - 1
                        if dddd &gt; 1:
                            shuju1 = np.vstack((guiji[abc[nnn - 2, 0]], KKK3[:, np.arange(aaa * 2 - 2, aaa * 2)]))
                        if dddd == 1:
                            shuju1 = np.vstack((KKK2[:, np.arange(abc[nnn - 2, 0] * 2 - 2, abc[nnn - 2, 0] * 2)],
                                                KKK3[:, np.arange(aaa * 2 - 2, aaa * 2)]))
                        new1[:, O2 + nnc - 1] = KK3[:, aaa - 1]
                        zhongjian[O2 + nnc - 1] = shuju1
                        # zhongjian[O2 + nnc-1][np.all(shuju1 == 0,axis=1),:].fill(0)
            for t10 in range(0, O3):
                guiji[t10] = zhongjian[t10]

#Perform centroid distance traversal calculation when the number of centroids on the later day is less than the previous day

        if O3 &lt;= O2:
            new2 = O2
            dddd = dddd + 1
            for t1 in range(1, O2 + 1):
                for t2 in range(1, O3 + 1):
                    jl[t1 - 1, t2 - 1] = np.sqrt(
                        (KK2[0, t1 - 1] - KK3[0, t2 - 1]) ** 2 + (KK2[1, t1 - 1] - KK3[1, t2 - 1]) ** 2)
            index = np.argmin(jl[:O2, :O3], axis=1)
            for t3 in range(1, O2 + 1):
                aaa = int(index[t3 - 1] + 1)
                if dddd == 1:
                    shuju1 = np.vstack(
                        (KKK2[:, np.arange(t3 * 2 - 2, t3 * 2)], KKK3[:, np.arange(aaa * 2 - 2, aaa * 2)]))
                    new1[:, t3 - 1] = KK3[:, aaa - 1]
                    LL6 = LL6 + 1
                if dddd &gt; 1:
                    shuju1 = np.vstack((guiji[t3 - 1], KKK3[:, np.arange(aaa * 2 - 2, aaa * 2)]))
                    new1[:, t3 - 1] = KK3[:, aaa - 1]
                    LL6 = LL6 + 1
                guiji[t3 - 1] = shuju1
                # guiji[t3][np.all(shuju1 == 0, axis=1),:].fill(0)

    for key, value in guiji.items():
        value = np.hstack((np.array(value), np.arange(1, len(value) + 1).reshape((len(value), 1))))
        df1 = value.tolist()
        # df = pd.DataFrame(value)
        names = [[&#39;X&#39;, &#39;Y&#39;, &#39;date_index&#39;]] + df1
        # df.columns = names
        # df.to_excel(os.path.join(save_path, csv_name.replace(&#39;.csv&#39;,&#39;&#39;), &#39;ni_traj{}.xlsx&#39;.format(key + 1)), sheet_name=&#39;Sheet1&#39;, index=False)
        savecsvs(os.path.join(save_path, csv_name.replace(&#39;.csv&#39;,&#39;&#39;), &#39;group{}.csv&#39;.format(key + 1)),names)</code></pre>
</details>
</dd>
<dt id="came.Part_2_functions_for_eachstep.interpolation"><code class="name flex">
<span>def <span class="ident">interpolation</span></span>(<span>date, length, initial_data)</span>
</code></dt>
<dd>
<div class="desc"><p>This function is to finish interpolation for missing dates</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>date</code></strong></dt>
<dd>The observation date</dd>
<dt><strong><code>length</code></strong></dt>
<dd>The length of the data</dd>
<dt><strong><code>initial_data</code></strong></dt>
<dd>The data after coordinates conversion</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>initial_data</code></dt>
<dd>The data results after interpolation</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def interpolation(date,length,initial_data):
    &#34;&#34;&#34;
       This function is to finish interpolation for missing dates

       Args:
           date: The observation date
           length: The length of the data
           initial_data: The data after coordinates conversion

       Returns:
           initial_data: The data results after interpolation
    &#34;&#34;&#34;
    k = 43101
    lose_date = []
    now_date = []
    all_date = [i for i in range(k, k + 365)]
    for i in range(length):
        now_date.append(date[i])
    for i in all_date:
        if i not in now_date:
            lose_date.append(i)
    # print(lose_date)


    for lose in lose_date:
        x = []
        y = []
        for data in initial_data:
            if data[2] == &#34;OBSERVATION DATE&#34;:
                continue
            if 0 &lt; lose - int(data[2]) &lt;= 2:
                x.append(data[0])
                y.append(data[1])
        initial_data.append([sum(x) / len(x), sum(y) / len(y), lose])
    return initial_data</code></pre>
</details>
</dd>
<dt id="came.Part_2_functions_for_eachstep.knn"><code class="name flex">
<span>def <span class="ident">knn</span></span>(<span>save_path, csv_name, key)</span>
</code></dt>
<dd>
<div class="desc"><p>This function is for KNN algorithm</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>save_path</code></strong></dt>
<dd>The path for saving the result file</dd>
<dt><strong><code>csv_name</code></strong></dt>
<dd>The species name being processed</dd>
<dt><strong><code>key</code></strong></dt>
<dd>The number for file naming</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>Lon</code></dt>
<dd>The longitude after KNN fitting</dd>
<dt><code>Lat</code></dt>
<dd>The latitude after KNN fitting</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def knn(save_path, csv_name,key):
    &#34;&#34;&#34;
       This function is for KNN algorithm

       Args:
           save_path: The path for saving the result file
           csv_name: The species name being processed
           key: The number for file naming

       Returns:
           Lon: The longitude after KNN fitting
           Lat: The latitude after KNN fitting

    &#34;&#34;&#34;

    df = pd.read_csv(os.path.join(save_path, csv_name.replace(&#39;.csv&#39;, &#39;&#39;), &#39;group{}.csv&#39;.format(key + 1)))
    date = df[&#34;date_index&#34;]
    xx = df[&#34;date_index&#34;]
    xx = xx + 43100

    X = df[[&#39;date_index&#39;]]  # Features (date)
    y_longitude = df[&#39;Y&#39;]  # Target variable (longitude)
    y_latitude = df[&#39;X&#39;]  # Target variable (latitude)


    # Train the model
    knn_longitude = KNeighborsRegressor(n_neighbors=5)
    knn_latitude = KNeighborsRegressor(n_neighbors=5)
    knn_longitude.fit(X, y_longitude)
    knn_latitude.fit(X, y_latitude)

    y_knn_longitude_pred = knn_longitude.predict(X)
    y_knn_latitude_pred = knn_latitude.predict(X)

    # Draw the pictures
    plt.figure(figsize=(16, 8))
    plt.subplot(1, 2, 1)
    plt.scatter(xx, y_longitude, color=&#39;darkorange&#39;, label=&#39;data&#39;)
    plt.plot(xx, y_knn_longitude_pred, color=&#39;navy&#39;, lw=2, label=&#39;KNN&#39;)
    # plt.plot(X_all, y_gb_longitude_pred, color=&#39;c&#39;, lw=2, label=&#39;Gradient Boosting&#39;)
    plt.xlabel(&#39;Date&#39;)
    plt.ylabel(&#39;Longitude(meter)&#39;)
    #plt.title(&#39;Longitude&#39;)
    plt.legend()

    plt.subplot(1, 2, 2)
    plt.scatter(xx, y_latitude, color=&#39;darkorange&#39;, label=&#39;data&#39;)
    plt.plot(xx, y_knn_latitude_pred, color=&#39;navy&#39;, lw=2, label=&#39;KNN&#39;)
    # plt.plot(X_all, y_gb_latitude_pred, color=&#39;c&#39;, lw=2, label=&#39;Gradient Boosting&#39;)
    plt.xlabel(&#39;Date&#39;)
    plt.ylabel(&#39;Latitude(meter)&#39;)
    #plt.title(&#39;Latitude&#39;)
    plt.legend()
    plt.tight_layout()
    # plt.show()
    plt.savefig(os.path.join(save_path, csv_name.replace(&#39;.csv&#39;, &#39;&#39;), &#39;KNN{}.jpg&#39;.format(key + 1)))
    plt.close()

    # Calculate the indexes
    mse_longitude = mean_squared_error(y_longitude, y_knn_longitude_pred)
    mse_latitude = mean_squared_error(y_latitude, y_knn_latitude_pred)

    rmse_longitude = np.sqrt(mse_longitude)
    rmse_latitude = np.sqrt(mse_latitude)

    r2_score_longitude = r2_score(y_longitude, y_knn_longitude_pred)
    r2_score_latitude = r2_score(y_latitude, y_knn_latitude_pred)
    try:
        readcsv(save_path + csv_name.replace(&#39;.csv&#39;, &#39;&#39;) + &#39;/{}.csv&#39;.format(&#39;evaluation_index&#39;))
    except:
        savecsv(save_path + csv_name.replace(&#39;.csv&#39;, &#39;&#39;) + &#39;/{}.csv&#39;.format(&#39;evaluation_index&#39;),
                [&#39;mse_longitude&#39;, &#39;mse_latitude&#39;, &#39;rmse_longitude&#39;, &#39;rmse_latitude&#39;, &#39;r2_score_longitude&#39;,
                 &#39;r2_score_latitude&#39;])
    savecsv(save_path + csv_name.replace(&#39;.csv&#39;, &#39;&#39;) + &#39;/{}.csv&#39;.format(&#39;evaluation_index&#39;),
            [mse_longitude, mse_latitude, rmse_longitude, rmse_latitude, r2_score_longitude, r2_score_latitude])


    datas = [[&#34;X*&#34;, &#34;Y*&#34;,&#34;date_index&#34;]]
    # datas = []
    for i in range(len(date)):
        datas.append([y_knn_latitude_pred[i], y_knn_longitude_pred[i],date[i]])
    # data_write(os.path.join(save_path, csv_name.replace(&#39;.csv&#39;,&#39;&#39;), &#39;result_{}.xls&#39;.format(key + 1)), datas)
    savecsvs(os.path.join(save_path, csv_name.replace(&#39;.csv&#39;,&#39;&#39;), &#39;fitting_result{}.csv&#39;.format(key + 1)), datas)

#Coordinate conversion to wgs84

    Lon, Lat = projection2wgs84(y_knn_longitude_pred, y_knn_latitude_pred)
    return Lon, Lat</code></pre>
</details>
</dd>
<dt id="came.Part_2_functions_for_eachstep.map_1"><code class="name flex">
<span>def <span class="ident">map_1</span></span>(<span>save_path, csv_name, type_name)</span>
</code></dt>
<dd>
<div class="desc"><p>This function is for showing the trajectories on the map</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>save_path</code></strong></dt>
<dd>The path for storing the result figures</dd>
<dt><strong><code>csv_name</code></strong></dt>
<dd>The name of the species to be processed</dd>
<dt><strong><code>type_name</code></strong></dt>
<dd>The fitting model chosen for centroids fitting</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>True</code></dt>
<dd>Omitted</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def map_1(save_path,csv_name,type_name):
    &#34;&#34;&#34;
       This function is for showing the trajectories on the map

       Args:
           save_path: The path for storing the result figures
           csv_name: The name of the species to be processed
           type_name: The fitting model chosen for centroids fitting

       Returns:
           True: Omitted

    &#34;&#34;&#34;
    # plt.rcParams[&#39;figure.figsize&#39;] = (28, 8)
    # plt.show()

    excel_list = os.listdir(os.path.join(save_path, csv_name.replace(&#39;.csv&#39;, &#39;&#39;)))
    excel_list1 = []
    for csv_excel in excel_list:
        if &#39;group&#39; in csv_excel:
            excel_list1.append(csv_excel)

    LON = []
    LAT = []
    for i in range(len(excel_list1)):
        if type_name == &#39;gam&#39;:
            Lon, Lat = gam(save_path, csv_name, i)
        elif type_name == &#39;randomforest&#39;:
            Lon, Lat = randomforest(save_path, csv_name, i)
        elif type_name == &#39;knn&#39;:
            Lon, Lat = knn(save_path, csv_name, i)

        LON.append(Lon)
        LAT.append(Lat)

    m = Basemap(llcrnrlat=-60, urcrnrlat=90, llcrnrlon=-180, urcrnrlon=-20)  # Instantiate a map
    m.drawcoastlines()  # Draw the coastline
    m.drawmapboundary(fill_color=&#39;white&#39;)
    m.fillcontinents(lake_color=&#39;white&#39;)  # Draw the continents and fill them in white

    parallels = np.arange(-90., 90., 10.)  # Draw latitudes with ranges [-90,90] and intervals of 10
    m.drawparallels(parallels, labels=[False, True, True, False], color=&#39;none&#39;)
    meridians = np.arange(-180., 180., 20.)  # Draw the longitude with a range of [-180,180] and an interval of 10
    m.drawmeridians(meridians, labels=[True, False, False, True], color=&#39;none&#39;)
    for doc in range(0, len(LON)):
        colorMap = [&#39;red&#39;, &#39;darkorange&#39;, &#39;gold&#39;, &#39;greenyellow&#39;, &#39;pink&#39;, &#39;limegreen&#39;, &#39;mediumturquoise&#39;,
                    &#39;dodgerblue&#39;,
                    &#39;navy&#39;, &#39;blue&#39;, &#39;mediumorchid&#39;, &#39;fuchsia&#39;]
        # Show labels
        label = [&#39;January&#39;, &#39;February&#39;, &#39;March&#39;, &#39;April&#39;, &#39;May&#39;, &#39;June&#39;, &#39;July&#39;, &#39;August&#39;, &#39;September&#39;, &#39;October&#39;,
                 &#39;November&#39;, &#39;December&#39;]

        marker = [&#39;x&#39;, &#39;.&#39;, &#39;o&#39;, &#39;|&#39;, &#39;*&#39;, &#39;.&#39;, &#39;&lt;&#39;, &#39;&gt;&#39;, &#39;,&#39;, &#39;.&#39;, &#39;.&#39;, &#39;v&#39;, &#39;x&#39;, &#39;o&#39;, &#39;|&#39;, &#39;*&#39;, &#39;&lt;&#39;, &#39;^&#39;, &#39;.&#39;, &#39;*&#39;, &#39;v&#39;, &#39;*&#39;, &#39;,&#39;, &#39;y&#39;, &#39;.&#39;, &#39;.&#39;, &#39;.&#39;, &#39;.&#39;]
        j = 0
        # print(len(lon))
        flag = True


        for i in range(0, len(LON[doc]) - 30, 30):
            # print(i)
            if doc == 0:
                m.plot(LON[doc][i:i + 30], LAT[doc][i:i + 30], marker=marker[doc], linewidth=0.4,
                       color=colorMap[j],
                       markersize=0.5, label=label[
                        j])
                # plt.show()
                j += 1
                if j == 12:
                    j = 0
                    if flag:
                        plt.legend(loc=&#39;lower left&#39;, shadow=True)
                        flag = False
                    continue
            else:
                m.plot(LON[doc][i:i + 30], LAT[doc][i:i + 30], marker=marker[doc], linewidth=0.4,
                       color=colorMap[j],
                       markersize=0.5)
                # plt.show()
                j += 1
                if j == 12:
                    j = 0
                    if flag:
                        plt.legend(loc=&#39;lower left&#39;, shadow=True)
                        flag = False
                    continue

    plt.xlabel(&#39;Lon&#39;, labelpad=10)
    plt.ylabel(&#39;Lat&#39;)
    plt.savefig(os.path.join(save_path, csv_name.replace(&#39;.csv&#39;, &#39;&#39;), &#39;trajectories.jpg&#39;), dpi=1000)
    # plt.show()
    plt.close()</code></pre>
</details>
</dd>
<dt id="came.Part_2_functions_for_eachstep.mean_shift"><code class="name flex">
<span>def <span class="ident">mean_shift</span></span>(<span>SLDF_df, save_path, csv_name)</span>
</code></dt>
<dd>
<div class="desc"><p>This function is for getting centroids of high-density subpopulations by Meanshift algorithm</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>SLDF_df</code></strong></dt>
<dd>The data after sldf outlier detection</dd>
<dt><strong><code>save_path</code></strong></dt>
<dd>The path for saving the result file</dd>
<dt><strong><code>csv_name</code></strong></dt>
<dd>The species name being processed</dd>
</dl>
<p>Returns:
result: The data results after Meanshift clustering</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def mean_shift(SLDF_df,save_path,csv_name):
    &#34;&#34;&#34;
       This function is for getting centroids of high-density subpopulations by Meanshift algorithm

       Args:
           SLDF_df: The data after sldf outlier detection
           save_path: The path for saving the result file
           csv_name: The species name being processed

        Returns:
           result: The data results after Meanshift clustering
    &#34;&#34;&#34;
    # datas = pd.read_excel(&#39;data/clean_window_data.xlsx&#39;)
    datas = SLDF_df.drop([&#39;SLDF&#39;], axis=1)
    result = []
    result.append([&#34;LATITUDE&#34;, &#34;LONGITUDE&#34;, &#34;OBSERVATION DATE&#34;])
    for date in tqdm(range(43101, 43466)):
    #for date in range(43101, 43119):
        #print(date)
        data = datas.loc[date == datas[&#39;OBSERVATION DATE&#39;]]  # .values.tolist()#[&#34;answer&#34;]
        data = data.iloc[:, :2]
        data = np.array(data)
        if len(data) == 0:
            continue

        ms = MeanShift()
        ms.fit(data)
        labels = ms.labels_
        cluster_centers = ms.cluster_centers_

        labels_unique = np.unique(labels)
        n_clusters = len(labels_unique)

        for c in cluster_centers:
            result.append([float(c[0]), float(c[1]), date])

        colors = cycle(&#39;bcmyk&#39;)
        if date % 10 == 0:
            for k, color in zip(range(n_clusters), colors):
                # current_member indicates true if the label is k and false if not
                current_member = labels == k
                cluster_center = cluster_centers[k]
                # Draw plots
                plt.plot(data[current_member, 0], data[current_member, 1], color + &#39;.&#39;)
                # Draw circles
                plt.plot(cluster_center[0], cluster_center[1], &#39;o&#39;,
                         markerfacecolor=color,
                         markeredgecolor=&#39;k&#39;,
                         markersize=14)

                plt.xlabel(&#39;Latitude(meter)&#39;)

                plt.ylabel(&#39;Longitude(meter)&#39;)
            # plt.show()
            plt.savefig(os.path.join(save_path, csv_name.replace(&#39;.csv&#39;, &#39;&#39;), &#39;centroids_{}.jpg&#39;.format(date)), dpi=1000)
            plt.close()
    return result</code></pre>
</details>
</dd>
<dt id="came.Part_2_functions_for_eachstep.projection2wgs84"><code class="name flex">
<span>def <span class="ident">projection2wgs84</span></span>(<span>lat, lon)</span>
</code></dt>
<dd>
<div class="desc"><p>This function is for coordinates conversion into
geographical ones</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>a</code></strong></dt>
<dd>The coordinates of longitude</dd>
<dt><strong><code>b</code></strong></dt>
<dd>The coordinates of latitude</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>lon</code></dt>
<dd>The geographical coordinates of longitude</dd>
<dt><code>lat</code></dt>
<dd>The geographical coordinates of latitude</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def projection2wgs84(lat, lon):
    &#34;&#34;&#34;
       This function is for coordinates conversion into  geographical ones

       Args:
           a: The coordinates of longitude
           b: The coordinates of latitude

       Returns:
           lon: The geographical coordinates of longitude
           lat: The geographical coordinates of latitude
    &#34;&#34;&#34;
    global projection
    crs_WGS84 = CRS.from_epsg(4326)
    crs_projection = CRS.from_epsg(projection)
    transformer = Transformer.from_crs(crs_projection, crs_WGS84)
    m, n = transformer.transform(lat, lon)
    return n, m</code></pre>
</details>
</dd>
<dt id="came.Part_2_functions_for_eachstep.randomforest"><code class="name flex">
<span>def <span class="ident">randomforest</span></span>(<span>save_path, csv_name, key)</span>
</code></dt>
<dd>
<div class="desc"><p>This function is for Random forests algorithm</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>save_path</code></strong></dt>
<dd>The path for saving the result file</dd>
<dt><strong><code>csv_name</code></strong></dt>
<dd>The species name being processed</dd>
<dt><strong><code>key</code></strong></dt>
<dd>The number for file naming</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>Lon</code></dt>
<dd>The longitude after Random Forests algorithm</dd>
<dt><code>Lat</code></dt>
<dd>The latitude after Random Forests algorithm</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def randomforest(save_path, csv_name,key):
    &#34;&#34;&#34;
       This function is for Random forests algorithm

       Args:
           save_path: The path for saving the result file
           csv_name: The species name being processed
           key: The number for file naming

       Returns:
           Lon: The longitude after Random Forests algorithm
           Lat: The latitude after Random Forests algorithm

    &#34;&#34;&#34;
    df = pd.read_csv(os.path.join(save_path, csv_name.replace(&#39;.csv&#39;, &#39;&#39;), &#39;group{}.csv&#39;.format(key + 1)))
    date = df[&#34;date_index&#34;]
    xx = df[&#34;date_index&#34;]
    xx = xx + 43100

    X = df[[&#39;date_index&#39;]]  # Features (date)
    y_longitude = df[&#39;Y&#39;]  # Target variable (longitude)
    y_latitude = df[&#39;X&#39;]  # Target variable (latitude)

    # Train the model
    rf_longitude = RandomForestRegressor(n_estimators=100, random_state=42)
    rf_latitude = RandomForestRegressor(n_estimators=100, random_state=42)
    rf_longitude.fit(X, y_longitude)
    rf_latitude.fit(X, y_latitude)

    y_rf_longitude_pred = rf_longitude.predict(X)
    y_rf_latitude_pred = rf_latitude.predict(X)


    # Draw the pictures
    plt.figure(figsize=(16, 8))
    plt.subplot(1, 2, 1)
    plt.scatter(xx, y_longitude, color=&#39;darkorange&#39;, label=&#39;data&#39;)
    plt.plot(xx, y_rf_longitude_pred, color=&#39;navy&#39;, lw=2, label=&#39;Random Forest&#39;)
    # plt.plot(X_all, y_gb_longitude_pred, color=&#39;c&#39;, lw=2, label=&#39;Gradient Boosting&#39;)
    plt.xlabel(&#39;Date&#39;)
    plt.ylabel(&#39;Longitude(meter)&#39;)
    #plt.title(&#39;Longitude&#39;)
    plt.legend()

    plt.subplot(1, 2, 2)
    plt.scatter(xx, y_latitude, color=&#39;darkorange&#39;, label=&#39;data&#39;)
    plt.plot(xx, y_rf_latitude_pred, color=&#39;navy&#39;, lw=2, label=&#39;Random Forest&#39;)
    # plt.plot(X_all, y_gb_latitude_pred, color=&#39;c&#39;, lw=2, label=&#39;Gradient Boosting&#39;)
    plt.xlabel(&#39;Date&#39;)
    plt.ylabel(&#39;Latitude(meter)&#39;)
    #plt.title(&#39;Latitude&#39;)
    plt.legend()
    plt.tight_layout()
    # plt.show()
    plt.savefig(os.path.join(save_path, csv_name.replace(&#39;.csv&#39;, &#39;&#39;), &#39;randomforest{}.jpg&#39;.format(key + 1)))
    plt.close()


    # Calculate the indexes
    mse_longitude = mean_squared_error(y_longitude, y_rf_longitude_pred)
    mse_latitude = mean_squared_error(y_latitude, y_rf_latitude_pred)

    rmse_longitude = np.sqrt(mse_longitude)
    rmse_latitude = np.sqrt(mse_latitude)

    r2_score_longitude = r2_score(y_longitude, y_rf_longitude_pred)
    r2_score_latitude = r2_score(y_latitude, y_rf_latitude_pred)
    try:
        readcsv(save_path + csv_name.replace(&#39;.csv&#39;,&#39;&#39;) + &#39;/{}.csv&#39;.format(&#39;evaluation_index&#39;))
    except:
        savecsv(save_path + csv_name.replace(&#39;.csv&#39;, &#39;&#39;) + &#39;/{}.csv&#39;.format(&#39;evaluation_index&#39;),
                [&#39;mse_longitude&#39;, &#39;mse_latitude&#39;, &#39;rmse_longitude&#39;, &#39;rmse_latitude&#39;, &#39;r2_score_longitude&#39;, &#39;r2_score_latitude&#39;])
    savecsv(save_path + csv_name.replace(&#39;.csv&#39;,&#39;&#39;) + &#39;/{}.csv&#39;.format(&#39;evaluation_index&#39;),
            [mse_longitude,mse_latitude,rmse_longitude,rmse_latitude,r2_score_longitude,r2_score_latitude])


    datas = [[&#34;X*&#34;, &#34;Y*&#34;,&#34;date_index&#34;]]
    # datas = []
    for i in range(len(date)):
        datas.append([y_rf_latitude_pred[i], y_rf_longitude_pred[i],date[i]])
    # data_write(os.path.join(save_path, csv_name.replace(&#39;.csv&#39;,&#39;&#39;), &#39;result_{}.xls&#39;.format(key + 1)), datas)
    savecsvs(os.path.join(save_path, csv_name.replace(&#39;.csv&#39;,&#39;&#39;), &#39;fitting_result{}.csv&#39;.format(key + 1)), datas)

#Coordinate conversion to wgs84

    Lon, Lat = projection2wgs84(y_rf_longitude_pred, y_rf_latitude_pred)
    return Lon, Lat</code></pre>
</details>
</dd>
<dt id="came.Part_2_functions_for_eachstep.rolling_window"><code class="name flex">
<span>def <span class="ident">rolling_window</span></span>(<span>initial_data, save_path, csv_name)</span>
</code></dt>
<dd>
<div class="desc"><p>This function is for rolling_window algorithm</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>initial_data</code></strong></dt>
<dd>The data after interpolation</dd>
<dt><strong><code>save_path</code></strong></dt>
<dd>The path for saving the result file</dd>
<dt><strong><code>csv_name</code></strong></dt>
<dd>The species name being processed</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>rolling_window_data_df</code></dt>
<dd>The data results after rolling_window</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def rolling_window(initial_data,save_path,csv_name):
    &#34;&#34;&#34;
       This function is for rolling_window algorithm

       Args:
           initial_data: The data after interpolation
           save_path: The path for saving the result file
           csv_name: The species name being processed

       Returns:
           rolling_window_data_df: The data results after rolling_window
    &#34;&#34;&#34;
    Rolling_window_data = []
    Rolling_window_data.append([&#34;LATITUDE&#34;, &#34;LONGITUDE&#34;, &#34;OBSERVATION DATE&#34;])

    k = 43101
    for i in range(k, k + 365):
        for data in initial_data:
            if data[2] == &#34;OBSERVATION DATE&#34;:
                continue
            if -3 &lt; data[2] - i &lt;= 3:
                Rolling_window_data.append([data[0], data[1], i])

    # window_data_df = pd.DataFrame(window_data, columns=False)
    # window_data_df.to_csv(&#39;426.csv&#39;, index=False)
    Rolling_window_data_df = pd.DataFrame(Rolling_window_data[1:], columns=Rolling_window_data[0])
    Rolling_window_data_df.to_csv(os.path.join(save_path, csv_name.replace(&#39;.csv&#39;,&#39;&#39;), &#39;rolling_window_data.csv&#39;), index=False)
    return Rolling_window_data_df</code></pre>
</details>
</dd>
<dt id="came.Part_2_functions_for_eachstep.sldf"><code class="name flex">
<span>def <span class="ident">sldf</span></span>(<span>x)</span>
</code></dt>
<dd>
<div class="desc"><p>This function is for outlier detection based on sldf values</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>x</code></strong></dt>
<dd>The input data</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>result</code></dt>
<dd>The result after sldf outlier detection</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def sldf(x):
    &#34;&#34;&#34;
       This function is for outlier detection based on sldf values

       Args:
           x: The input data

       Returns:
           result: The result after sldf outlier detection
    &#34;&#34;&#34;
    n = len(x)
    column = len(x[0])
    x_max = np.max(x)
    x_min = np.min(x)
    x_ = (x - x_min) / (x_max - x_min)
    k = 50
    lens = 1 / k
    position_x = np.ceil(x_ / lens)

    for i in range(len(position_x)):
        for j in range(len(position_x[0])):
            if position_x[i][j] == 0:
                position_x[i][j] = 1

    B = np.lexsort([position_x[:, 1], position_x[:, 0]])
    A = position_x[B, :]
    A = A.astype(int)
    count = np.zeros((k, k))
    for i in range(n):
        count[A[i][0] - 1][A[i][1] - 1] += 1
    max_count = np.max(count)

    q = 2
    q = q * max_count
    w = [0.5, 0.5]
    dist = np.zeros((n, n))
    for i in range(n):
        dist[:, i] = w[0] * ((x_[:, 0] - x_[i, 0]) ** 2) + w[1] * ((x_[:, 1] - x_[i, 1]) ** 2)
    dist = np.sqrt(dist)
    max_dist = np.max(dist)
    k = max_dist
    N = []
    for i in range(len(dist)):
        for j in range(len(dist[0])):
            Ni, Nj = j, i
            N.append((Ni, Nj))

    N = np.array(N)
    u = np.zeros(n)
    SLDR = np.zeros(n)
    N_i = N[:, 0]
    N_j = N[:, 1]

    for i in range(n):
        tmp = np.argwhere(N_j == i)
        tmp_E = int(max(tmp))
        tmp_S = int(min(tmp))
        tmp_N = N[tmp_S: tmp_E + 1, :]
        tmp_D = []
        for j in range(len(tmp_N)):
            a, b = tmp_N[j]
            tmp_D.append(dist[a, b])
        tmp_ji = tmp_E - tmp_S + 1
        u[i] = sum(tmp_D) / tmp_ji
        tmp_c = (tmp_D - u[i]) ** 2
        SLDR[i] = sum(tmp_c) / tmp_ji

    SLDIR = np.zeros(n)
    for i in range(n):
        tmp = np.argwhere(N_j == i)
        tmp_E = int(max(tmp))
        tmp_S = int(min(tmp))
        tmp = SLDR[N_i[tmp_S: tmp_E + 1]]
        SLDIR[i] = sum(tmp) / tmp_ji

    SLDF = SLDR / SLDIR
    # print(SLDF.shape, x.shape)
    selected_index = np.argsort(SLDF)[:int(0.8 * len(SLDF) + 1)]
    # print(selected_index.shape)
    SLDF_new = SLDF[selected_index]
    result = np.concatenate((x[selected_index], SLDF_new[:, np.newaxis]), axis=1)
    return result</code></pre>
</details>
</dd>
<dt id="came.Part_2_functions_for_eachstep.wgs84toprojection"><code class="name flex">
<span>def <span class="ident">wgs84toprojection</span></span>(<span>lat, lon)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def wgs84toprojection(lat, lon):
    global projection
    &#34;&#34;&#34;
       This function is for coordinates conversion 

       Args:
           lat: The geographical coordinates of latitude
           lon: The geographical coordinates of longitude

       Returns:
           m: The coordinates of latitude after conversion
           n: The coordinates of longitude after conversion
    &#34;&#34;&#34;
    crs_WGS84 = CRS.from_epsg(4326)
    crs_projection = CRS.from_epsg(projection)
    transformer = Transformer.from_crs(crs_WGS84, crs_projection)
    m, n = transformer.transform(lat, lon)
    return n, m</code></pre>
</details>
</dd>
</dl>
</section>
<section>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="came" href="index.html">came</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="two-column">
<li><code><a title="came.Part_2_functions_for_eachstep.create_folder" href="#came.Part_2_functions_for_eachstep.create_folder">create_folder</a></code></li>
<li><code><a title="came.Part_2_functions_for_eachstep.file_names" href="#came.Part_2_functions_for_eachstep.file_names">file_names</a></code></li>
<li><code><a title="came.Part_2_functions_for_eachstep.gam" href="#came.Part_2_functions_for_eachstep.gam">gam</a></code></li>
<li><code><a title="came.Part_2_functions_for_eachstep.get_all_csv" href="#came.Part_2_functions_for_eachstep.get_all_csv">get_all_csv</a></code></li>
<li><code><a title="came.Part_2_functions_for_eachstep.get_initial_data" href="#came.Part_2_functions_for_eachstep.get_initial_data">get_initial_data</a></code></li>
<li><code><a title="came.Part_2_functions_for_eachstep.get_sldf" href="#came.Part_2_functions_for_eachstep.get_sldf">get_sldf</a></code></li>
<li><code><a title="came.Part_2_functions_for_eachstep.group" href="#came.Part_2_functions_for_eachstep.group">group</a></code></li>
<li><code><a title="came.Part_2_functions_for_eachstep.interpolation" href="#came.Part_2_functions_for_eachstep.interpolation">interpolation</a></code></li>
<li><code><a title="came.Part_2_functions_for_eachstep.knn" href="#came.Part_2_functions_for_eachstep.knn">knn</a></code></li>
<li><code><a title="came.Part_2_functions_for_eachstep.map_1" href="#came.Part_2_functions_for_eachstep.map_1">map_1</a></code></li>
<li><code><a title="came.Part_2_functions_for_eachstep.mean_shift" href="#came.Part_2_functions_for_eachstep.mean_shift">mean_shift</a></code></li>
<li><code><a title="came.Part_2_functions_for_eachstep.projection2wgs84" href="#came.Part_2_functions_for_eachstep.projection2wgs84">projection2wgs84</a></code></li>
<li><code><a title="came.Part_2_functions_for_eachstep.randomforest" href="#came.Part_2_functions_for_eachstep.randomforest">randomforest</a></code></li>
<li><code><a title="came.Part_2_functions_for_eachstep.rolling_window" href="#came.Part_2_functions_for_eachstep.rolling_window">rolling_window</a></code></li>
<li><code><a title="came.Part_2_functions_for_eachstep.sldf" href="#came.Part_2_functions_for_eachstep.sldf">sldf</a></code></li>
<li><code><a title="came.Part_2_functions_for_eachstep.wgs84toprojection" href="#came.Part_2_functions_for_eachstep.wgs84toprojection">wgs84toprojection</a></code></li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>